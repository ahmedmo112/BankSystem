name: FastestAI - Generic C++ GTest Runner

on:
  workflow_dispatch:
    inputs:
      test_names:
        description: 'JSON array of test names to run (empty for all tests)'
        required: false
        default: '[]'
      analysis_result_id:
        description: 'Analysis result ID for test report'
        required: true
      build_system:
        description: 'Build system to use'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'cmake'
          - 'make'
          - 'direct'
      cpp_standard:
        description: 'C++ standard version'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'c++11'
          - 'c++14'
          - 'c++17'
          - 'c++20'
      compiler:
        description: 'Compiler to use'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'gcc'
          - 'clang'

jobs:
  analyze-project:
    runs-on: ubuntu-latest
    outputs:
      build-system: ${{ steps.detect.outputs.build-system }}
      cpp-standard: ${{ steps.detect.outputs.cpp-standard }}
      compiler: ${{ steps.detect.outputs.compiler }}
      source-files: ${{ steps.detect.outputs.source-files }}
      test-files: ${{ steps.detect.outputs.test-files }}
      include-dirs: ${{ steps.detect.outputs.include-dirs }}
      has-custom-main: ${{ steps.detect.outputs.has-custom-main }}
      project-structure: ${{ steps.detect.outputs.project-structure }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Detect project configuration
        id: detect
        run: |
          set -e
          
          echo "=== Analyzing C++ project structure ==="
          
          # Detect build system
          BUILD_SYSTEM="${{ github.event.inputs.build_system }}"
          if [ "$BUILD_SYSTEM" = "auto" ]; then
            if [ -f "CMakeLists.txt" ]; then
              BUILD_SYSTEM="cmake"
            elif [ -f "Makefile" ] || [ -f "makefile" ]; then
              BUILD_SYSTEM="make"
            else
              BUILD_SYSTEM="direct"
            fi
          fi
          echo "build-system=$BUILD_SYSTEM" >> $GITHUB_OUTPUT
          echo "Detected build system: $BUILD_SYSTEM"
          
          # Detect C++ standard
          CPP_STANDARD="${{ github.event.inputs.cpp_standard }}"
          if [ "$CPP_STANDARD" = "auto" ]; then
            # Try to detect from CMakeLists.txt or common patterns
            if [ -f "CMakeLists.txt" ]; then
              CPP_STD=$(grep -i "CMAKE_CXX_STANDARD\|set.*CXX_STANDARD\|std=" CMakeLists.txt | head -1 | grep -o "1[0-9]" | head -1 || echo "")
              if [ -n "$CPP_STD" ]; then
                CPP_STANDARD="c++$CPP_STD"
              fi
            fi
            # Default fallback
            [ "$CPP_STANDARD" = "auto" ] && CPP_STANDARD="c++14"
          fi
          echo "cpp-standard=$CPP_STANDARD" >> $GITHUB_OUTPUT
          echo "Detected C++ standard: $CPP_STANDARD"
          
          # Detect compiler
          COMPILER="${{ github.event.inputs.compiler }}"
          if [ "$COMPILER" = "auto" ]; then
            # Default to gcc for better compatibility
            COMPILER="gcc"
          fi
          echo "compiler=$COMPILER" >> $GITHUB_OUTPUT
          echo "Detected compiler: $COMPILER"
          
          # Find source files (excluding test files and common build directories)
          SOURCE_FILES=$(find . \
            -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" \
            ! -path "*/build/*" ! -path "*/Build/*" ! -path "*/BUILD/*" \
            ! -path "*/test/*" ! -path "*/tests/*" ! -path "*/Test/*" ! -path "*/Tests/*" \
            ! -name "*test*" ! -name "*Test*" ! -name "*TEST*" \
            ! -name "main.cpp" ! -name "main.cc" \
            | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "source-files=$SOURCE_FILES" >> $GITHUB_OUTPUT
          echo "Found source files: $SOURCE_FILES"
          
          # Find test files
          TEST_FILES=$(find . \
            -name "*test*.cpp" -o -name "*test*.cc" -o -name "*test*.cxx" \
            -o -name "*Test*.cpp" -o -name "*Test*.cc" -o -name "*Test*.cxx" \
            -o -name "*TEST*.cpp" -o -name "*TEST*.cc" -o -name "*TEST*.cxx" \
            -o -path "*/test*/*.cpp" -o -path "*/Test*/*.cpp" \
            ! -path "*/build/*" ! -path "*/Build/*" ! -path "*/BUILD/*" \
            | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "test-files=$TEST_FILES" >> $GITHUB_OUTPUT
          echo "Found test files: $TEST_FILES"
          
          # Find include directories
          INCLUDE_DIRS=$(find . -type d \
            -name "include" -o -name "inc" -o -name "header*" -o -name "src" \
            ! -path "*/build/*" ! -path "*/Build/*" ! -path "*/BUILD/*" \
            | head -10 | sed 's/^/-I/' | tr '\n' ' ')
          echo "include-dirs=$INCLUDE_DIRS" >> $GITHUB_OUTPUT
          echo "Found include directories: $INCLUDE_DIRS"
          
          # Check for custom main function
          HAS_CUSTOM_MAIN="false"
          if grep -r "int main(" . --include="*.cpp" --include="*.cc" --include="*.cxx" >/dev/null 2>&1; then
            HAS_CUSTOM_MAIN="true"
          fi
          echo "has-custom-main=$HAS_CUSTOM_MAIN" >> $GITHUB_OUTPUT
          echo "Has custom main: $HAS_CUSTOM_MAIN"
          
          # Determine project structure
          if [ -d "src" ] && [ -d "test" ]; then
            PROJECT_STRUCTURE="src-test"
          elif [ -d "src" ] && [ -d "tests" ]; then
            PROJECT_STRUCTURE="src-tests"
          elif find . -maxdepth 1 -name "*.cpp" | head -1 >/dev/null; then
            PROJECT_STRUCTURE="flat"
          else
            PROJECT_STRUCTURE="custom"
          fi
          echo "project-structure=$PROJECT_STRUCTURE" >> $GITHUB_OUTPUT
          echo "Project structure: $PROJECT_STRUCTURE"

  test:
    needs: analyze-project
    runs-on: ubuntu-latest
    strategy:
      matrix:
        approach: [cmake, direct]
      fail-fast: false
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up build environment
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            libgtest-dev \
            libgmock-dev \
            pkg-config \
            jq
          
          # Install GTest from source for older systems
          cd /usr/src/googletest || cd /usr/src/gtest
          sudo mkdir -p build
          cd build
          sudo cmake .. -DBUILD_GMOCK=ON
          sudo make -j$(nproc)
          sudo make install || sudo cp lib/*.a /usr/lib/ || sudo cp googlemock/lib*.a googletest/lib*.a /usr/lib/ 2>/dev/null || true
          
          # Update library cache with proper permissions
          sudo ldconfig
          
          # Verify GTest installation
          pkg-config --exists gtest || echo "GTest pkg-config not found, will use manual linking"

      - name: Setup compiler
        run: |
          set -e
          COMPILER="${{ needs.analyze-project.outputs.compiler }}"
          
          if [ "$COMPILER" = "gcc" ]; then
            sudo apt-get install -y gcc g++
            echo "CC=gcc" >> $GITHUB_ENV
            echo "CXX=g++" >> $GITHUB_ENV
          elif [ "$COMPILER" = "clang" ]; then
            sudo apt-get install -y clang
            echo "CC=clang" >> $GITHUB_ENV
            echo "CXX=clang++" >> $GITHUB_ENV
          fi

      - name: Build with CMake
        if: matrix.approach == 'cmake' && (needs.analyze-project.outputs.build-system == 'cmake' || needs.analyze-project.outputs.build-system == 'auto')
        run: |
          set -e
          
          # Create CMakeLists.txt if it doesn't exist
          if [ ! -f "CMakeLists.txt" ]; then
            echo "Creating generic CMakeLists.txt..."
            cat > CMakeLists.txt << 'EOF'
          cmake_minimum_required(VERSION 3.10)
          project(FastestAI_Test)
          
          # Set C++ standard
          set(CMAKE_CXX_STANDARD ${{ needs.analyze-project.outputs.cpp-standard == 'c++11' && '11' || needs.analyze-project.outputs.cpp-standard == 'c++14' && '14' || needs.analyze-project.outputs.cpp-standard == 'c++17' && '17' || needs.analyze-project.outputs.cpp-standard == 'c++20' && '20' || '14' }})
          set(CMAKE_CXX_STANDARD_REQUIRED ON)
          
          # Find packages
          find_package(GTest REQUIRED)
          find_package(Threads REQUIRED)
          
          # Include directories
          include_directories(${GTEST_INCLUDE_DIRS})
          
          # Auto-discover source files
          file(GLOB_RECURSE SOURCES 
            "*.cpp" "*.cc" "*.cxx"
            "src/*.cpp" "src/*.cc" "src/*.cxx"
          )
          
          # Filter out test files and main files
          list(FILTER SOURCES EXCLUDE REGEX ".*[Tt]est.*")
          list(FILTER SOURCES EXCLUDE REGEX ".*main\\.cpp$")
          
          # Auto-discover test files
          file(GLOB_RECURSE TEST_SOURCES 
            "*test*.cpp" "*test*.cc" "*test*.cxx"
            "*Test*.cpp" "*Test*.cc" "*Test*.cxx"
            "test/*.cpp" "tests/*.cpp"
          )
          
          # Create test executable
          if(TEST_SOURCES)
            add_executable(test_runner ${SOURCES} ${TEST_SOURCES})
            target_link_libraries(test_runner ${GTEST_LIBRARIES} ${GTEST_MAIN_LIBRARIES} Threads::Threads)
            
            # Add common include directories
            target_include_directories(test_runner PRIVATE 
              ${CMAKE_CURRENT_SOURCE_DIR}
              ${CMAKE_CURRENT_SOURCE_DIR}/src
              ${CMAKE_CURRENT_SOURCE_DIR}/include
              ${CMAKE_CURRENT_SOURCE_DIR}/inc
            )
          endif()
          EOF
          fi
          
          # Build
          mkdir -p build
          cd build
          cmake .. -DCMAKE_BUILD_TYPE=Debug
          make -j$(nproc)
          
          # Check if executable was created
          if [ -f "test_runner" ]; then
            echo "CMAKE_BUILD_SUCCESS=true" >> $GITHUB_ENV
            echo "TEST_EXECUTABLE=build/test_runner" >> $GITHUB_ENV
          else
            echo "CMAKE_BUILD_SUCCESS=false" >> $GITHUB_ENV
          fi

      - name: Build with Direct Compilation  
        if: matrix.approach == 'direct' && (env.CMAKE_BUILD_SUCCESS != 'true' || needs.analyze-project.outputs.build-system == 'direct')
        run: |
          set -e
          
          echo "=== Direct compilation approach ==="
          
          # Get file lists
          SOURCE_FILES='${{ needs.analyze-project.outputs.source-files }}'
          TEST_FILES='${{ needs.analyze-project.outputs.test-files }}'
          INCLUDE_DIRS="${{ needs.analyze-project.outputs.include-dirs }}"
          CPP_STANDARD="${{ needs.analyze-project.outputs.cpp-standard }}"
          
          echo "Source files: $SOURCE_FILES"
          echo "Test files: $TEST_FILES"
          echo "Include dirs: $INCLUDE_DIRS"
          
          # Convert JSON arrays to space-separated strings
          SOURCE_LIST=$(echo "$SOURCE_FILES" | jq -r '.[] | select(length > 0)' | tr '\n' ' ')
          TEST_LIST=$(echo "$TEST_FILES" | jq -r '.[] | select(length > 0)' | tr '\n' ' ')
          
          echo "Parsed source files: $SOURCE_LIST"
          echo "Parsed test files: $TEST_LIST"
          
          if [ -z "$TEST_LIST" ]; then
            echo "No test files found!"
            exit 1
          fi
          
          # Determine compiler flags
          COMPILER_FLAGS="-std=$CPP_STANDARD -Wall -g"
          LINKER_FLAGS="-pthread"
          
          # Try to link with GTest using pkg-config first
          if pkg-config --exists gtest; then
            GTEST_FLAGS=$(pkg-config --cflags --libs gtest)
            echo "Using pkg-config for GTest: $GTEST_FLAGS"
          else
            # Fallback to manual GTest linking - try multiple common locations
            GTEST_FLAGS=""
            
            # Check for GTest in standard locations
            if [ -f "/usr/lib/x86_64-linux-gnu/libgtest.a" ]; then
              GTEST_FLAGS="-I/usr/include/gtest -L/usr/lib/x86_64-linux-gnu -lgtest -lgtest_main"
            elif [ -f "/usr/local/lib/libgtest.a" ]; then
              GTEST_FLAGS="-I/usr/include/gtest -L/usr/local/lib -lgtest -lgtest_main"
            elif [ -f "/usr/lib/libgtest.a" ]; then
              GTEST_FLAGS="-I/usr/include/gtest -L/usr/lib -lgtest -lgtest_main"
            else
              # Last resort - try to find GTest files
              GTEST_LIB=$(find /usr -name "libgtest.a" 2>/dev/null | head -1)
              if [ -n "$GTEST_LIB" ]; then
                GTEST_DIR=$(dirname "$GTEST_LIB")
                GTEST_FLAGS="-I/usr/include/gtest -L$GTEST_DIR -lgtest -lgtest_main"
              else
                echo "ERROR: Could not find GTest libraries"
                exit 1
              fi
            fi
            
            echo "Using manual GTest linking: $GTEST_FLAGS"
          fi
          
          # Build command
          BUILD_CMD="$CXX $COMPILER_FLAGS $INCLUDE_DIRS $SOURCE_LIST $TEST_LIST $GTEST_FLAGS $LINKER_FLAGS -o test_runner"
          
          echo "Build command: $BUILD_CMD"
          
          # Execute build
          eval $BUILD_CMD
          
          if [ -f "test_runner" ]; then
            echo "DIRECT_BUILD_SUCCESS=true" >> $GITHUB_ENV
            echo "TEST_EXECUTABLE=test_runner" >> $GITHUB_ENV
            chmod +x test_runner
          else
            echo "DIRECT_BUILD_SUCCESS=false" >> $GITHUB_ENV
          fi

      - name: Run Tests
        if: env.CMAKE_BUILD_SUCCESS == 'true' || env.DIRECT_BUILD_SUCCESS == 'true'
        run: |
          set -e
          
          TEST_EXECUTABLE="${TEST_EXECUTABLE:-test_runner}"
          
          if [ ! -f "$TEST_EXECUTABLE" ]; then
            echo "Test executable not found: $TEST_EXECUTABLE"
            exit 1
          fi
          
          # Parse test filter
          TEST_FILTER=$(echo '${{ github.event.inputs.test_names }}' | jq -r 'if . == [] then empty else join(":") end')
          
          # Prepare output file name
          OUTPUT_FILE="${{ matrix.approach }}_results.xml"
          
          # List available tests first
          echo "=== Available Tests ==="
          ./$TEST_EXECUTABLE --gtest_list_tests || echo "Could not list tests"
          
          # Run tests
          if [ -n "$TEST_FILTER" ]; then
            echo "Running filtered tests: $TEST_FILTER"
            ./$TEST_EXECUTABLE --gtest_filter="$TEST_FILTER" --gtest_output=xml:$OUTPUT_FILE
          else
            echo "Running all tests"
            ./$TEST_EXECUTABLE --gtest_output=xml:$OUTPUT_FILE
          fi
          
          # Verify results file
          if [ -f "$OUTPUT_FILE" ]; then
            echo "TEST_RESULTS_FILE=$OUTPUT_FILE" >> $GITHUB_ENV
            echo "Test results generated successfully"
            
            # Show summary
            echo "=== Test Summary ==="
            grep -o 'tests="[0-9]*"' $OUTPUT_FILE || echo "Could not parse test count"
            grep -o 'failures="[0-9]*"' $OUTPUT_FILE || echo "Could not parse failure count"
            grep -o 'errors="[0-9]*"' $OUTPUT_FILE || echo "Could not parse error count"
          else
            echo "Test results file not generated!"
            exit 1
          fi

      - name: Send Results to FastestAI
        if: env.TEST_RESULTS_FILE && (env.CMAKE_BUILD_SUCCESS == 'true' || env.DIRECT_BUILD_SUCCESS == 'true')
        env:
          FASTEST_SECRET_KEY: ${{ secrets.FASTEST_SECRET_KEY }}
        run: |
          set -e
          
          RESULTS_FILE="${TEST_RESULTS_FILE}"
          
          if [ ! -f "$RESULTS_FILE" ]; then
            echo "Results file not found: $RESULTS_FILE"
            exit 1
          fi
          
          # Send to FastestAI
          response_code=$(curl -s -o response.txt -w "%{http_code}" -X POST \
            "https://fastestai.tech/codebase/test-results?analysis_result_id=${{ github.event.inputs.analysis_result_id }}&build_approach=${{ matrix.approach }}" \
            -H "X-Secret-Key: $FASTEST_SECRET_KEY" \
            -H "Content-Type: application/xml" \
            --data-binary "@$RESULTS_FILE")
          
          if [ "$response_code" -eq 200 ]; then
            echo "✅ Test results sent successfully to FastestAI (approach: ${{ matrix.approach }})"
            echo "Response: $(cat response.txt)"
            exit 0
          else
            echo "❌ Failed to send results. Status: $response_code"
            echo "Response: $(cat response.txt)"
            
            # Don't fail the job, just log the error
            echo "::warning::Failed to send results to FastestAI, but tests completed successfully"
          fi

  report:
    needs: [analyze-project, test]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Generate Summary Report
        run: |
          echo "# FastestAI C++ Test Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Project Analysis" >> $GITHUB_STEP_SUMMARY
          echo "- **Build System**: ${{ needs.analyze-project.outputs.build-system }}" >> $GITHUB_STEP_SUMMARY
          echo "- **C++ Standard**: ${{ needs.analyze-project.outputs.cpp-standard }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: ${{ needs.analyze-project.outputs.compiler }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Project Structure**: ${{ needs.analyze-project.outputs.project-structure }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Execution Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Analysis Result ID**: ${{ github.event.inputs.analysis_result_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Test Filter**: ${{ github.event.inputs.test_names }}" >> $GITHUB_STEP_SUMMARY
