name: FastestAI - Generic C++ GTest Runner

on:
  workflow_dispatch:
    inputs:
      test_names:
        description: 'JSON array of test names to run (empty for all tests)'
        required: false
        default: '[]'
      analysis_result_id:
        description: 'Analysis result ID for test report'
        required: true
      build_system:
        description: 'Build system to use'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'cmake'
          - 'make'
          - 'direct'
      cpp_standard:
        description: 'C++ standard version'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'c++11'
          - 'c++14'
          - 'c++17'
          - 'c++20'
      compiler:
        description: 'Compiler to use'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'gcc'
          - 'clang'

jobs:
  analyze-project:
    runs-on: ubuntu-latest
    outputs:
      build-system: ${{ steps.detect.outputs.build-system }}
      cpp-standard: ${{ steps.detect.outputs.cpp-standard }}
      compiler: ${{ steps.detect.outputs.compiler }}
      source-files: ${{ steps.detect.outputs.source-files }}
      test-files: ${{ steps.detect.outputs.test-files }}
      include-dirs: ${{ steps.detect.outputs.include-dirs }}
      has-custom-main: ${{ steps.detect.outputs.has-custom-main }}
      project-structure: ${{ steps.detect.outputs.project-structure }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Detect project configuration
        id: detect
        run: |
          set -e
          
          echo "=== Analyzing C++ project structure ==="
          
          # Detect build system
          BUILD_SYSTEM="${{ github.event.inputs.build_system }}"
          if [ "$BUILD_SYSTEM" = "auto" ]; then
            if [ -f "CMakeLists.txt" ]; then
              BUILD_SYSTEM="cmake"
            elif [ -f "Makefile" ] || [ -f "makefile" ]; then
              BUILD_SYSTEM="make"
            else
              BUILD_SYSTEM="direct"
            fi
          fi
          echo "build-system=$BUILD_SYSTEM" >> $GITHUB_OUTPUT
          echo "Detected build system: $BUILD_SYSTEM"
          
          # Detect C++ standard
          CPP_STANDARD="${{ github.event.inputs.cpp_standard }}"
          if [ "$CPP_STANDARD" = "auto" ]; then
            # Try to detect from CMakeLists.txt or common patterns
            if [ -f "CMakeLists.txt" ]; then
              CPP_STD=$(grep -i "CMAKE_CXX_STANDARD\|set.*CXX_STANDARD\|std=" CMakeLists.txt | head -1 | grep -o "1[0-9]" | head -1 || echo "")
              if [ -n "$CPP_STD" ]; then
                CPP_STANDARD="c++$CPP_STD"
              fi
            fi
            # Default fallback
            [ "$CPP_STANDARD" = "auto" ] && CPP_STANDARD="c++14"
          fi
          echo "cpp-standard=$CPP_STANDARD" >> $GITHUB_OUTPUT
          echo "Detected C++ standard: $CPP_STANDARD"
          
          # Detect compiler
          COMPILER="${{ github.event.inputs.compiler }}"
          if [ "$COMPILER" = "auto" ]; then
            # Default to gcc for better compatibility
            COMPILER="gcc"
          fi
          echo "compiler=$COMPILER" >> $GITHUB_OUTPUT
          echo "Detected compiler: $COMPILER"
          
          # Find all C++ files first
          echo "=== Finding all C++ files ==="
          find . -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" \
            ! -path "*/build/*" ! -path "*/Build/*" ! -path "*/BUILD/*" \
            | sort > /tmp/all_cpp_files.txt
          
          echo "All C++ files found:"
          cat /tmp/all_cpp_files.txt
          
          # Find test files with more precise patterns
          echo "=== Identifying test files ==="
          grep -E "(test|Test|TEST)" /tmp/all_cpp_files.txt > /tmp/test_candidates.txt || touch /tmp/test_candidates.txt
          
          # Also check for files in test directories
          find . -path "*/test*/*.cpp" -o -path "*/Test*/*.cpp" -o -path "*/tests/*.cpp" \
            ! -path "*/build/*" ! -path "*/Build/*" ! -path "*/BUILD/*" \
            >> /tmp/test_candidates.txt || true
          
          # Remove duplicates and create final test file list
          sort /tmp/test_candidates.txt | uniq > /tmp/final_test_files.txt
          TEST_FILES=$(cat /tmp/final_test_files.txt | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "test-files=$TEST_FILES" >> $GITHUB_OUTPUT
          echo "Found test files: $TEST_FILES"
          
          # Find source files (everything that's not a test file or main file)
          echo "=== Identifying source files ==="
          # Start with all files, then exclude test files and main files
          cp /tmp/all_cpp_files.txt /tmp/source_candidates.txt
          
          # Remove test files
          if [ -s /tmp/final_test_files.txt ]; then
            while IFS= read -r testfile; do
              grep -v "^$testfile$" /tmp/source_candidates.txt > /tmp/temp_sources.txt || true
              mv /tmp/temp_sources.txt /tmp/source_candidates.txt
            done < /tmp/final_test_files.txt
          fi
          
          # Remove main files
          grep -v -E "(main\.cpp|main\.cc|main\.cxx)$" /tmp/source_candidates.txt > /tmp/final_source_files.txt || touch /tmp/final_source_files.txt
          
          SOURCE_FILES=$(cat /tmp/final_source_files.txt | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "source-files=$SOURCE_FILES" >> $GITHUB_OUTPUT
          echo "Found source files: $SOURCE_FILES"
          
          # Clean up temp files
          rm -f /tmp/all_cpp_files.txt /tmp/test_candidates.txt /tmp/final_test_files.txt /tmp/source_candidates.txt /tmp/final_source_files.txt /tmp/temp_sources.txt
          
          # Find include directories
          INCLUDE_DIRS=$(find . -type d \
            -name "include" -o -name "inc" -o -name "header*" -o -name "src" \
            ! -path "*/build/*" ! -path "*/Build/*" ! -path "*/BUILD/*" \
            | head -10 | sed 's/^/-I/' | tr '\n' ' ')
          echo "include-dirs=$INCLUDE_DIRS" >> $GITHUB_OUTPUT
          echo "Found include directories: $INCLUDE_DIRS"
          
          # Check for custom main function in test files
          HAS_CUSTOM_MAIN="false"
          if echo "$TEST_FILES" | jq -r '.[]' | xargs grep -l "int main(" 2>/dev/null | head -1 >/dev/null; then
            HAS_CUSTOM_MAIN="true"
          fi
          echo "has-custom-main=$HAS_CUSTOM_MAIN" >> $GITHUB_OUTPUT
          echo "Has custom main in tests: $HAS_CUSTOM_MAIN"
          
          # Determine project structure
          if [ -d "src" ] && [ -d "test" ]; then
            PROJECT_STRUCTURE="src-test"
          elif [ -d "src" ] && [ -d "tests" ]; then
            PROJECT_STRUCTURE="src-tests"
          elif find . -maxdepth 1 -name "*.cpp" | head -1 >/dev/null; then
            PROJECT_STRUCTURE="flat"
          else
            PROJECT_STRUCTURE="custom"
          fi
          echo "project-structure=$PROJECT_STRUCTURE" >> $GITHUB_OUTPUT
          echo "Project structure: $PROJECT_STRUCTURE"

  test:
    needs: analyze-project
    runs-on: ubuntu-latest
    strategy:
      matrix:
        approach: [cmake, direct]
      fail-fast: false
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up build environment
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            libgtest-dev \
            libgmock-dev \
            pkg-config \
            jq \
            gdb \
            file
          
          # Install GTest from source for older systems
          cd /usr/src/googletest 2>/dev/null || cd /usr/src/gtest
          sudo mkdir -p build
          cd build
          sudo cmake .. -DBUILD_GMOCK=ON -DCMAKE_CXX_FLAGS="-march=x86-64 -mtune=generic"
          sudo make -j$(nproc)
          sudo make install || sudo cp lib/*.a /usr/lib/ || sudo cp googlemock/lib*.a googletest/lib*.a /usr/lib/ 2>/dev/null || true
          
          # Ensure GTest is available
          sudo ldconfig
          pkg-config --exists gtest || echo "GTest pkg-config not found, will use manual linking"

      - name: Setup compiler
        run: |
          set -e
          COMPILER="${{ needs.analyze-project.outputs.compiler }}"
          
          if [ "$COMPILER" = "gcc" ]; then
            sudo apt-get install -y gcc g++
            echo "CC=gcc" >> $GITHUB_ENV
            echo "CXX=g++" >> $GITHUB_ENV
          elif [ "$COMPILER" = "clang" ]; then
            sudo apt-get install -y clang
            echo "CC=clang" >> $GITHUB_ENV
            echo "CXX=clang++" >> $GITHUB_ENV
          fi

      - name: Build with CMake
        if: matrix.approach == 'cmake' && (needs.analyze-project.outputs.build-system == 'cmake' || needs.analyze-project.outputs.build-system == 'auto')
        run: |
          set -e
          
          # Create CMakeLists.txt if it doesn't exist
          if [ ! -f "CMakeLists.txt" ]; then
            echo "Creating generic CMakeLists.txt..."
            cat > CMakeLists.txt << 'EOF'
          cmake_minimum_required(VERSION 3.10)
          project(FastestAI_Test)
          
          # Set C++ standard
          set(CMAKE_CXX_STANDARD ${{ needs.analyze-project.outputs.cpp-standard == 'c++11' && '11' || needs.analyze-project.outputs.cpp-standard == 'c++14' && '14' || needs.analyze-project.outputs.cpp-standard == 'c++17' && '17' || needs.analyze-project.outputs.cpp-standard == 'c++20' && '20' || '14' }})
          set(CMAKE_CXX_STANDARD_REQUIRED ON)
          
          # Set conservative compiler flags for better compatibility
          set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=x86-64 -mtune=generic -O1 -g")
          
          # Find packages
          find_package(GTest REQUIRED)
          find_package(Threads REQUIRED)
          
          # Include directories
          include_directories(${GTEST_INCLUDE_DIRS})
          
          # Auto-discover source files
          file(GLOB_RECURSE SOURCES 
            "*.cpp" "*.cc" "*.cxx"
            "src/*.cpp" "src/*.cc" "src/*.cxx"
          )
          
          # Filter out test files and main files
          list(FILTER SOURCES EXCLUDE REGEX ".*[Tt]est.*")
          list(FILTER SOURCES EXCLUDE REGEX ".*main\\.cpp$")
          list(FILTER SOURCES EXCLUDE REGEX ".*main\\.cc$")
          list(FILTER SOURCES EXCLUDE REGEX ".*main\\.cxx$")
          
          # Auto-discover test files
          file(GLOB_RECURSE TEST_SOURCES 
            "*test*.cpp" "*test*.cc" "*test*.cxx"
            "*Test*.cpp" "*Test*.cc" "*Test*.cxx"
            "test/*.cpp" "tests/*.cpp"
          )
          
          # Create test executable
          if(TEST_SOURCES)
            add_executable(test_runner ${SOURCES} ${TEST_SOURCES})
            target_link_libraries(test_runner ${GTEST_LIBRARIES} ${GTEST_MAIN_LIBRARIES} Threads::Threads)
            
            # Add common include directories
            target_include_directories(test_runner PRIVATE 
              ${CMAKE_CURRENT_SOURCE_DIR}
              ${CMAKE_CURRENT_SOURCE_DIR}/src
              ${CMAKE_CURRENT_SOURCE_DIR}/include
              ${CMAKE_CURRENT_SOURCE_DIR}/inc
            )
          endif()
          EOF
          fi
          
          # Build
          mkdir -p build
          cd build
          cmake .. -DCMAKE_BUILD_TYPE=Debug
          make -j$(nproc)
          
          # Check if executable was created
          if [ -f "test_runner" ]; then
            echo "CMAKE_BUILD_SUCCESS=true" >> $GITHUB_ENV
            echo "TEST_EXECUTABLE=build/test_runner" >> $GITHUB_ENV
          else
            echo "CMAKE_BUILD_SUCCESS=false" >> $GITHUB_ENV
          fi

      - name: Build with Direct Compilation  
        if: matrix.approach == 'direct' && (env.CMAKE_BUILD_SUCCESS != 'true' || needs.analyze-project.outputs.build-system == 'direct')
        run: |
          set -e
          
          echo "=== Direct compilation approach ==="
          
          # Get file lists
          SOURCE_FILES='${{ needs.analyze-project.outputs.source-files }}'
          TEST_FILES='${{ needs.analyze-project.outputs.test-files }}'
          INCLUDE_DIRS="${{ needs.analyze-project.outputs.include-dirs }}"
          CPP_STANDARD="${{ needs.analyze-project.outputs.cpp-standard }}"
          HAS_CUSTOM_MAIN="${{ needs.analyze-project.outputs.has-custom-main }}"
          
          echo "Source files: $SOURCE_FILES"
          echo "Test files: $TEST_FILES"
          echo "Include dirs: $INCLUDE_DIRS"
          echo "Has custom main: $HAS_CUSTOM_MAIN"
          
          # Create temporary files to handle deduplication properly
          echo "$SOURCE_FILES" | jq -r '.[] | select(length > 0)' | sort | uniq > /tmp/source_files.txt
          echo "$TEST_FILES" | jq -r '.[] | select(length > 0)' | sort | uniq > /tmp/test_files.txt
          
          # Debug: show what files we found
          echo "=== Source files found ==="
          cat /tmp/source_files.txt
          echo "=== Test files found ==="
          cat /tmp/test_files.txt
          
          # Convert to arrays for processing
          SOURCE_LIST=$(cat /tmp/source_files.txt | tr '\n' ' ')
          TEST_LIST=$(cat /tmp/test_files.txt | tr '\n' ' ')
          
          echo "Parsed source files: $SOURCE_LIST"
          echo "Parsed test files: $TEST_LIST"
          
          # Ensure we have test files
          if [ ! -s /tmp/test_files.txt ]; then
            echo "No test files found!"
            exit 1
          fi
          
          # Filter source files (remove main files and any files that appear in test list)
          FILTERED_SOURCES=""
          for src in $SOURCE_LIST; do
            if [ -f "$src" ]; then
              # Skip main files
              if [[ "$src" == *"main.cpp"* ]] || [[ "$src" == *"main.cc"* ]] || [[ "$src" == *"main.cxx"* ]]; then
                echo "Skipping main file: $src"
                continue
              fi
              # Skip if this file is also in test list (to avoid duplication)
              if grep -Fxq "$src" /tmp/test_files.txt; then
                echo "Skipping duplicate file (found in test list): $src"
                continue
              fi
              FILTERED_SOURCES="$FILTERED_SOURCES $src"
            fi
          done
          
          # Ensure test files are unique and exist
          FILTERED_TESTS=""
          for test in $TEST_LIST; do
            if [ -f "$test" ]; then
              # Check if already added
              if [[ "$FILTERED_TESTS" != *"$test"* ]]; then
                FILTERED_TESTS="$FILTERED_TESTS $test"
              else
                echo "Skipping duplicate test file: $test"
              fi
            fi
          done
          
          echo "Final filtered source files: $FILTERED_SOURCES"
          echo "Final filtered test files: $FILTERED_TESTS"
          
          # Check if test files contain main function
          GTEST_MAIN_FLAG=""
          if [ "$HAS_CUSTOM_MAIN" = "true" ]; then
            echo "Test files contain custom main function"
            GTEST_MAIN_FLAG=""
          else
            echo "Using GTest main function"
            GTEST_MAIN_FLAG="-lgtest_main"
          fi
          
          # Conservative compiler flags to avoid illegal instruction errors
          COMPILER_FLAGS="-std=$CPP_STANDARD -Wall -g -march=x86-64 -mtune=generic -O1 -fno-strict-aliasing"
          LINKER_FLAGS="-pthread"
          
          # Try to link with GTest using pkg-config first
          if pkg-config --exists gtest; then
            GTEST_CFLAGS=$(pkg-config --cflags gtest)
            GTEST_LIBS=$(pkg-config --libs gtest)
            echo "Using pkg-config for GTest: $GTEST_CFLAGS $GTEST_LIBS"
          else
            # Fallback to manual GTest linking
            GTEST_CFLAGS="-I/usr/include/gtest"
            GTEST_LIBS="-L/usr/lib -L/usr/local/lib -lgtest"
            echo "Using manual GTest linking: $GTEST_CFLAGS $GTEST_LIBS"
          fi
          
          # Build command with proper file handling
          BUILD_CMD="$CXX $COMPILER_FLAGS $INCLUDE_DIRS $GTEST_CFLAGS $FILTERED_SOURCES $FILTERED_TESTS $GTEST_LIBS $GTEST_MAIN_FLAG $LINKER_FLAGS -o test_runner"
          
          echo "Build command: $BUILD_CMD"
          
          # Execute build
          eval $BUILD_CMD
          
          if [ -f "test_runner" ]; then
            echo "DIRECT_BUILD_SUCCESS=true" >> $GITHUB_ENV
            echo "TEST_EXECUTABLE=test_runner" >> $GITHUB_ENV
            chmod +x test_runner
            
            # Verify the binary
            echo "=== Binary Information ==="
            file test_runner
            ldd test_runner || echo "Could not check dependencies"
          else
            echo "DIRECT_BUILD_SUCCESS=false" >> $GITHUB_ENV
          fi
          
          # Cleanup temp files
          rm -f /tmp/source_files.txt /tmp/test_files.txt

      - name: Debug Binary
        if: env.CMAKE_BUILD_SUCCESS == 'true' || env.DIRECT_BUILD_SUCCESS == 'true'
        run: |
          set -e
          
          TEST_EXECUTABLE="${TEST_EXECUTABLE:-test_runner}"
          
          if [ ! -f "$TEST_EXECUTABLE" ]; then
            echo "Test executable not found: $TEST_EXECUTABLE"
            exit 1
          fi
          
          echo "=== Binary Debug Information ==="
          file "$TEST_EXECUTABLE"
          echo ""
          echo "=== CPU Information ==="
          cat /proc/cpuinfo | grep -E "model name|flags" | head -2
          echo ""
          echo "=== Library Dependencies ==="
          ldd "$TEST_EXECUTABLE" || echo "Could not check dependencies"
          echo ""
          echo "=== Testing Basic Execution ==="
          timeout 10s "$TEST_EXECUTABLE" --help || echo "Help command failed or timed out"

      - name: Run Tests
        if: env.CMAKE_BUILD_SUCCESS == 'true' || env.DIRECT_BUILD_SUCCESS == 'true'
        run: |
          set -e
          
          TEST_EXECUTABLE="${TEST_EXECUTABLE:-test_runner}"
          
          if [ ! -f "$TEST_EXECUTABLE" ]; then
            echo "Test executable not found: $TEST_EXECUTABLE"
            exit 1
          fi
          
          # Parse test filter
          TEST_FILTER=$(echo '${{ github.event.inputs.test_names }}' | jq -r 'if . == [] then empty else join(":") end')
          
          # Prepare output file name
          OUTPUT_FILE="${{ matrix.approach }}_results.xml"
          
          # List available tests first with timeout and error handling
          echo "=== Available Tests ==="
          timeout 30s "$TEST_EXECUTABLE" --gtest_list_tests || {
            echo "Warning: Could not list tests (exit code: $?)"
            echo "Attempting to run tests anyway..."
          }
          
          # Run tests with timeout and better error handling
          echo "=== Running Tests ==="
          
          if [ -n "$TEST_FILTER" ]; then
            echo "Running filtered tests: $TEST_FILTER"
            timeout 300s "$TEST_EXECUTABLE" --gtest_filter="$TEST_FILTER" --gtest_output=xml:"$OUTPUT_FILE" || {
              EXIT_CODE=$?
              echo "Test execution failed with exit code: $EXIT_CODE"
              
              # Try to run with gdb to get more information about crashes
              if [ $EXIT_CODE -eq 132 ] || [ $EXIT_CODE -eq 139 ]; then
                echo "=== Crash detected, attempting to get stack trace ==="
                echo "run --gtest_filter=\"$TEST_FILTER\" --gtest_output=xml:$OUTPUT_FILE" > gdb_commands.txt
                echo "bt" >> gdb_commands.txt
                echo "quit" >> gdb_commands.txt
                timeout 60s gdb -batch -x gdb_commands.txt "$TEST_EXECUTABLE" || echo "Could not get stack trace"
              fi
              
              # Check if partial results were generated
              if [ -f "$OUTPUT_FILE" ]; then
                echo "Partial test results were generated"
              else
                # Create a minimal error report
                cat > "$OUTPUT_FILE" << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <testsuites tests="0" failures="1" disabled="0" errors="1" timestamp="$(date -u +%Y-%m-%dT%H:%M:%S)" time="0" name="AllTests">
            <testsuite name="TestExecutionError" tests="0" failures="1" disabled="0" errors="1" time="0">
              <testcase name="ExecutionFailed" status="run" time="0" classname="TestExecutionError">
                <error message="Test executable crashed or failed to run" type="RuntimeError">
                  Exit code: $EXIT_CODE
                  This may be due to:
                  - Illegal instruction (incompatible CPU features)
                  - Memory access violation
                  - Missing dependencies
                  - Compilation issues
                </error>
              </testcase>
            </testsuite>
          </testsuites>
          EOF
              fi
            }
          else
            echo "Running all tests"
            timeout 300s "$TEST_EXECUTABLE" --gtest_output=xml:"$OUTPUT_FILE" || {
              EXIT_CODE=$?
              echo "Test execution failed with exit code: $EXIT_CODE"
              
              # Try to run with gdb to get more information about crashes
              if [ $EXIT_CODE -eq 132 ] || [ $EXIT_CODE -eq 139 ]; then
                echo "=== Crash detected, attempting to get stack trace ==="
                echo "run --gtest_output=xml:$OUTPUT_FILE" > gdb_commands.txt
                echo "bt" >> gdb_commands.txt
                echo "quit" >> gdb_commands.txt
                timeout 60s gdb -batch -x gdb_commands.txt "$TEST_EXECUTABLE" || echo "Could not get stack trace"
              fi
              
              # Check if partial results were generated
              if [ -f "$OUTPUT_FILE" ]; then
                echo "Partial test results were generated"
              else
                # Create a minimal error report
                cat > "$OUTPUT_FILE" << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <testsuites tests="0" failures="1" disabled="0" errors="1" timestamp="$(date -u +%Y-%m-%dT%H:%M:%S)" time="0" name="AllTests">
            <testsuite name="TestExecutionError" tests="0" failures="1" disabled="0" errors="1" time="0">
              <testcase name="ExecutionFailed" status="run" time="0" classname="TestExecutionError">
                <error message="Test executable crashed or failed to run" type="RuntimeError">
                  Exit code: $EXIT_CODE
                  This may be due to:
                  - Illegal instruction (incompatible CPU features)
                  - Memory access violation
                  - Missing dependencies
                  - Compilation issues
                </error>
              </testcase>
            </testsuite>
          </testsuites>
          EOF
              fi
            }
          fi
          
          # Verify results file
          if [ -f "$OUTPUT_FILE" ]; then
            echo "TEST_RESULTS_FILE=$OUTPUT_FILE" >> $GITHUB_ENV
            echo "Test results file generated"
            
            # Show summary
            echo "=== Test Summary ==="
            grep -o 'tests="[0-9]*"' "$OUTPUT_FILE" || echo "Could not parse test count"
            grep -o 'failures="[0-9]*"' "$OUTPUT_FILE" || echo "Could not parse failure count"
            grep -o 'errors="[0-9]*"' "$OUTPUT_FILE" || echo "Could not parse error count"
            
            # Show first few lines of results for debugging
            echo "=== Results File Content (first 20 lines) ==="
            head -20 "$OUTPUT_FILE"
          else
            echo "Test results file was not generated!"
            exit 1
          fi

      - name: Send Results to FastestAI
        if: env.TEST_RESULTS_FILE && (env.CMAKE_BUILD_SUCCESS == 'true' || env.DIRECT_BUILD_SUCCESS == 'true')
        env:
          FASTEST_SECRET_KEY: ${{ secrets.FASTEST_SECRET_KEY }}
        run: |
          set -e
          
          RESULTS_FILE="${TEST_RESULTS_FILE}"
          
          if [ ! -f "$RESULTS_FILE" ]; then
            echo "Results file not found: $RESULTS_FILE"
            exit 1
          fi
          
          # Send to FastestAI
          response_code=$(curl -s -o response.txt -w "%{http_code}" -X POST \
            "https://fastestai.tech/codebase/test-results?analysis_result_id=${{ github.event.inputs.analysis_result_id }}&build_approach=${{ matrix.approach }}" \
            -H "X-Secret-Key: $FASTEST_SECRET_KEY" \
            -H "Content-Type: application/xml" \
            --data-binary "@$RESULTS_FILE")
          
          if [ "$response_code" -eq 200 ]; then
            echo "✅ Test results sent successfully to FastestAI (approach: ${{ matrix.approach }})"
            echo "Response: $(cat response.txt)"
            exit 0
          else
            echo "❌ Failed to send results. Status: $response_code"
            echo "Response: $(cat response.txt)"
            
            # Don't fail the job, just log the error
            echo "::warning::Failed to send results to FastestAI, but tests completed successfully"
          fi

  report:
    needs: [analyze-project, test]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Generate Summary Report
        run: |
          echo "# FastestAI C++ Test Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Project Analysis" >> $GITHUB_STEP_SUMMARY
          echo "- **Build System**: ${{ needs.analyze-project.outputs.build-system }}" >> $GITHUB_STEP_SUMMARY
          echo "- **C++ Standard**: ${{ needs.analyze-project.outputs.cpp-standard }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: ${{ needs.analyze-project.outputs.compiler }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Project Structure**: ${{ needs.analyze-project.outputs.project-structure }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Execution Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Analysis Result ID**: ${{ github.event.inputs.analysis_result_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Test Filter**: ${{ github.event.inputs.test_names }}" >> $GITHUB_STEP_SUMMARY
